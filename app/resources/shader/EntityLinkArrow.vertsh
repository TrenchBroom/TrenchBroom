#version 120

/*
 Copyright (C) 2010-2017 Kristian Duske
 
 This file is part of TrenchBroom.
 
 TrenchBroom is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 
 TrenchBroom is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with TrenchBroom. If not, see <http://www.gnu.org/licenses/>.
 */

uniform vec3 CameraPosition;

varying float distanceFromCamera;
varying vec4 color;

const float almostZero = 0.001;

struct Quat {
    float r;
    vec3 v;
};

Quat setRotation(vec3 axis, float angle) {
    Quat quat;
    quat.r = cos(angle / 2.0f);
    quat.v = axis * sin(angle / 2.0f);
    return quat;
}

bool eqEpsilon(float a, float b, float epsilon) {
    return abs(a - b) < epsilon;
}

/**
 * Creates a new quaternion that rotates the 1st given vector onto the 2nd given vector. Both vectors are
 * expected to be normalized.
 */
Quat makeQuat(vec3 from, vec3 to) {
    float cosAngle = dot(from, to);
    if (eqEpsilon(abs(cosAngle), 1.0, almostZero)) {
        return setRotation(vec3(0.0, 0.0, 1.0), 0.0);
    } else {
        vec3 axis = normalize(cross(from, to));
        float angle = acos(cosAngle);
        return setRotation(axis, angle);
    }
}

Quat quatMult(Quat left, Quat right) {
    float t = right.r;
    vec3 w = right.v;

    float nx = left.r * w.x + t * left.v.x + left.v.y * w.z - left.v.z * w.y;
    float ny = left.r * w.y + t * left.v.y + left.v.z * w.x - left.v.x * w.z;
    float nz = left.r * w.z + t * left.v.z + left.v.x * w.y - left.v.y * w.x;

    Quat result;
    result.r = left.r * t - dot(left.v, w);
    result.v[0] = nx;
    result.v[1] = ny;
    result.v[2] = nz;
    return result;
}

Quat conjugated(Quat left) {
    Quat result;
    result.r = left.r;
    result.v = -left.v;
    return result;
}

vec3 quatMult(Quat left, vec3 right) {
     Quat p;
     p.r = 0.0;
     p.v = right;
     p = quatMult(quatMult(left, p), conjugated(left));
     return p.v;
}

void main(void) {
    // TODO: use user-defined attributes for these
    vec3 arrowPosition = gl_MultiTexCoord0.xyz;
    vec3 lineDir = gl_MultiTexCoord1.xyz;

    vec3 worldVert;

    if (lineDir != vec3(0.0)) {
        Quat rotateFromPosXToLineDir = makeQuat(vec3(1.0, 0.0, 0.0), lineDir);

        // the above will point the arrow along the line, but we also want to roll it so it faces the camera.
        // see: http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-17-quaternions/#how-do-i-find-the-rotation-between-2-vectors-
        vec3 desiredUp = normalize(CameraPosition - arrowPosition);
        vec3 desiredRight = cross(lineDir, desiredUp);
        desiredUp = normalize(cross(desiredRight, lineDir)); // make desiredUp perpendicular to the lineDir

        vec3 currentUp = quatMult(rotateFromPosXToLineDir, vec3(0.0, 0.0, 1.0));
        Quat fixUp = makeQuat(currentUp, desiredUp);

        // now apply the rotations and translation to gl_Vertex
        worldVert = arrowPosition + quatMult(quatMult(fixUp, rotateFromPosXToLineDir), gl_Vertex.xyz);
    } else {
        // this is only the case when reusing this shader for the entity link lines, not the arrows

        worldVert = gl_Vertex.xyz;
    }

    gl_Position = gl_ProjectionMatrix * gl_ModelViewMatrix * vec4(worldVert, 1.0);
    distanceFromCamera = length(CameraPosition - gl_Vertex.xyz);
    color = gl_Color;
}
